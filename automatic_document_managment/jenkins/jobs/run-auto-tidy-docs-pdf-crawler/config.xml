<?xml version='1.0' encoding='UTF-8'?>
<flow-definition plugin="workflow-job@2.12.2">
  <actions>
    <org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction plugin="pipeline-model-definition@1.2.1">
      <jobProperties/>
      <triggers/>
      <parameters/>
    </org.jenkinsci.plugins.pipeline.modeldefinition.actions.DeclarativeJobPropertyTrackerAction>
  </actions>
  <description>As input, a directory with one or more pdf file.&#xd;
This script will take each pdf, scan them for text and propose (according to user configuration) where the file sould be tidy.</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>-1</daysToKeep>
        <numToKeep>10</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
  </properties>
  <definition class="org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition" plugin="workflow-cps@2.41">
    <script>pipeline {
    agent any

    environment {
		directory_to_scan = &apos;/mnt/xavier/to_tidy/&apos;
        scripts_directory = &quot;${env.EDM_CRAWLERS_BASE_DIR}/auto-tidy-docs-pdf&quot;
        auto_accept_edm_get_suggestion = &quot;true&quot;
    }

    stages {
        stage(&apos;Detect file&apos;) {
            steps {
                script {
                    file_name = sh (returnStdout: true, script:&quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; find . -type f -iname &apos;*.pdf&apos; ! -iname &apos;*locked*&apos; | head -1&quot;).trim()
                    echo &quot;file_name : ${file_name}&quot;

                    if (&quot;${file_name}&quot; == &quot;&quot;) {
                        currentBuild.result = &apos;ABORTED&apos;
                        error(&quot;No file to sort found, won&apos;t continue&quot;)
                    }
                }
            }
        }
        stage(&apos;Lock file&apos;){
            steps {
                echo &quot;Dealing with file : ${file_name}&quot;
                script {
                    locked_file_name = sh (returnStdout: true, script: &quot;echo ${file_name} | sed &apos;s/\\(.*\\)\\(.pdf\\)/\\1.locked\\2/g&apos;&quot;).trim()
                    echo &quot;locking file (name=${locked_file_name})&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; mv \&quot;${file_name}\&quot; \&quot;${locked_file_name}\&quot;&quot;
                }
            }
        }
        stage(&apos;Convert file to image&apos;){
            steps {
                script {
                    tiff_file_name = &quot;${locked_file_name}.tiff&quot;
                    echo &quot;tiff file (name=${tiff_file_name})&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; convert -depth 8 -density 300 -alpha Off \&quot;${locked_file_name}\&quot; \&quot;${tiff_file_name}\&quot;&quot;
                }
            }
        }
        stage(&apos;Extract text from image&apos;) {
            steps {
                script {
                    text_file_name = &quot;${locked_file_name}.txt&quot;
                    echo &quot;text (name=${text_file_name})&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; tesseract \&quot;${tiff_file_name}\&quot; -l fra - | sed &apos;/^[[:space:]]*\$/d&apos; &gt; \&quot;${text_file_name}\&quot;&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; cat \&quot;${text_file_name}\&quot;&quot;
                }
            }
        }
        stage(&apos;Getting forced by conf suggestion if exists&apos;) {
            steps {
                script {
                    sh &quot;cd \&quot;${env.scripts_directory}\&quot; &amp;&amp; ./magic_sorter.sh \&quot;${directory_to_scan}/${text_file_name}\&quot;&quot;
                    destination_file = sh (returnStdout: true, script:&quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; if [ -e \&quot;${text_file_name}.dest\&quot; ]; then cat \&quot;${text_file_name}.dest\&quot;; else echo \&quot;UNKNOWN\&quot;; fi&quot;).trim()
                    echo &quot;destination_file (name=${destination_file})&quot;
                }
            }
        }
        stage(&apos;Getting server magic suggestion if necessary&apos;) {
            steps {
                script {
                    if (&quot;${destination_file}&quot; == &quot;UNKNOWN&quot;) {
                        if (&quot;${auto_accept_edm_get_suggestion}&quot; != &quot;true&quot;) {
                            def userInput = input(
                                id: &apos;inputEdmUp&apos;,
                                message: &quot;Get suggestion from simple-data-search server ?&quot;
                            )
                        }
                        destination_file=sh (returnStdout: true, script:&quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; curl -s -XPOST \&quot;${env.EDM_HOST}/document/suggestTidy\&quot; -F file=@${text_file_name} | jq &apos;(.suggestedFileLocation + .suggestedFileName + \&quot;.pdf\&quot;)&apos;&quot;).trim()
                    }
                    echo &quot;destination_file (name=${destination_file})&quot;
                }
            }
        }
        stage(&apos;Remove working files&apos;) {
            steps {
                sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; rm -v \&quot;${locked_file_name}\&quot;.*&quot;
            }
        }
        stage(&apos;Waiting for an human to confirm my choice&apos;) {
            steps {
                script {
                    def inputConfirmMove = input(
                        id: &apos;inputConfirmMove&apos;,
                        message: &quot;Move the file to ... ?&quot;,
                        parameters: [
                            [$class: &apos;TextParameterDefinition&apos;, defaultValue: &quot;${destination_file}&quot;, description: &apos;Destination&apos;, name: &apos;destination&apos;]
                        ]
                    )
                    final_destination_file = inputConfirmMove;
                }
            }
        }
        stage(&apos;Moving !&apos;) {
            steps {
                script {
                    destinationFileNameEscaped=sh (returnStdout: true, script:&quot;echo \&quot;${final_destination_file}\&quot; | sed &apos;s/ /\\ /g&apos;&quot;).trim()
                    destinationDir = sh (returnStdout: true, script:&quot;dirname \&quot;${destinationFileNameEscaped}\&quot;&quot;).trim()
                    destinationFileName = sh (returnStdout: true, script:&quot;basename \&quot;${destinationFileNameEscaped}\&quot;&quot;).trim()
                    echo &quot;destinationDir (dir=${destinationDir})&quot;
                    echo &quot;destinationFileName (name=${destinationFileName})&quot;
                    sh &quot;mkdir -p \&quot;${destinationDir}\&quot;&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; mv -v \&quot;${locked_file_name}\&quot; \&quot;${destinationFileName}\&quot;&quot;
                    sh &quot;cd \&quot;${env.directory_to_scan}\&quot; &amp;&amp; mv -v \&quot;${destinationFileName}\&quot; \&quot;${destinationDir}\&quot;&quot;
                }
            }
        }
    }
}</script>
    <sandbox>true</sandbox>
  </definition>
  <triggers/>
  <disabled>false</disabled>
</flow-definition>